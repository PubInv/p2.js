<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Double Pendulum demo - p2.js physics engine</title>
    <script src="../build/p2.js"></script>
    <script src="../build/p2.renderer.js"></script>
    <link href="css/demo.css" rel="stylesheet"/>
    <meta name="description" content="Shows Chaotic Nature of Double Pendulum Compared to Single Pendulum.">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>
  <body>
    <section id="visualsection" style="{border: red;}">
    </section>
    <script>

/* TODO:

-- make the arm short enough to pass through the pivot to make it physically realizable
-- draw borders around the rectangles
-- detect ticks
-- draw table 
-- add a button to start game
-- change to simply raising both systems

This stuff is harder:
-- Stop game when the trace is new and report "Congratulations, you found new trace never found before!" 
"It took X seconds".
-- need a way to store the traces

*/ 
    var w, h, canvas, ctx, circleBody;
var bodies = {};
var bgraphs = {};

var renderer, stage, container, graphics, zoom,boxShape, boxBody, planeBody, planeShape;
var R = 0.7,
    L = R * 3 / 2;
var L1 = L/2;
var L2 = L/3;

var origin = [0,0];
var SL = L*2;
var TL = 1.0;
var r1 = 5;
var r2 = 3;
var L1 = SL*TL*r1/(r1+r2); // First arm
var L2 = SL*TL*r2/(r1+r2); // Second arm

var initial_angle_deg = 60, // raise angle, ccw from x axis, in degrees.
    initial_angle = (initial_angle_deg/360) * 2.0 * Math.PI;

var single_arm_pos = [origin[0] + Math.cos(initial_angle)*SL/2 , origin[1] + Math.sin(initial_angle)*SL/2 ];
var d1_arm_pos = [origin[0] + Math.cos(initial_angle)*L1/2 , origin[1] + Math.sin(initial_angle)*L1/2 ];
var d2_arm_pos = [d1_arm_pos[0] +  Math.cos(initial_angle)*(L1+L2)/2,
		  d1_arm_pos[1] +  Math.sin(initial_angle)*(L1+L2)/2];

 var PLAYER = Math.pow(2,0),
                        SINGLE =  Math.pow(2,1),
                        DOUBLE = Math.pow(2,2)

var buttons = {
    space : false,
    left :  false,
    right : false,
}
var sarmBody;

var armBody;
var secondArmBody;

var world;
var dummyBody1;
var dummyBody2;

var initAngVel = 5;

function random_color() {
    return '0x'+Math.floor(Math.random()*16777215).toString(16);
}

init();
animate();

function init_world() {
    world = new p2.World({
        gravity : [0,-1]
    });

    world.solver.iterations = 30;
    world.solver.tolerance = 0.01;

    // Create static dummy body that we can constrain other bodies to

    init_double_pendulum();
    init_single_pendulum();

}

function init(){

    init_world();
    // Pixi.js zoom level
    zoom = 150;

    // Initialize the stage
    renderer =  PIXI.autoDetectRenderer(1400, 800),
    stage = new PIXI.Stage(0xFFFFFF);

    // We use a container inside the stage for all our content
    // This enables us to zoom and translate the content
    container =     new PIXI.DisplayObjectContainer(),
    
    stage.addChild(container);

    // Add the canvas to the DOM
    var section = document.getElementById("visualsection");
    section.appendChild(renderer.view);

    // Add transform to the container
    container.position.x =  renderer.width/2; // center at origin
    container.position.y =  renderer.height/2;
    container.scale.x =  zoom;  // zoom in
    container.scale.y = -zoom; // Note: we flip the y axis to make "up" the physics "up"


    // Draw the box.
    graphics = new PIXI.Graphics();

    add_bodies(container,bodies);
    // Add the box to our container
    container.addChild(graphics);
}

function add_bodies(container,bodies,graphics) {
    for (var key in bodies) {
	var b = bodies[key];
        // Draw the box.
        var g = new PIXI.Graphics();
	bgraphs[key] = g;
	g.beginFill(b.color);
	var w = b.shapes[0].width;
	var h = b.shapes[0].height;
	g.drawRect(-w/2, -h/2, w, h);
	container.addChild(g);
    }

}

function normalizeAngle(angle){
                        angle = angle % (2*Math.PI);
                        if(angle < 0){
                            angle += (2*Math.PI);
                        }
                        return angle;
}

function drawBodies(graphics,bs,gs) {
    for (var key in bodies) {
	var b = bodies[key];
	var g = gs[key];
	// Transfer positions of the physics objects to Pixi.js
	g.position.x = b.position[0];
	g.position.y = b.position[1];
	g.rotation =   b.angle;

	if (b.name == "secondArmBody") {
	    graphics.beginFill(b.color);
	    var theta = normalizeAngle(b.angle);
	    theta = normalizeAngle(theta);
	    var len = L2/2;
	    var pos = [b.position[0]+len*Math.cos(theta),b.position[1]+len*Math.sin(theta)];
	    graphics.drawRect(pos[0], pos[1], 0.03, 0.03);	    
	}
    }
}


var lastCallTime = time();

// Animation loop
function animate(t){
    t = t || 0;
    requestAnimationFrame(animate);

    // Move physics bodies forward in time
    world.step(1/60);

    drawBodies(graphics,bodies,bgraphs);
    // Render scene
    renderer.render(stage);
}

// Get current time, in seconds.
function time(){
    return new Date().getTime() / 1000;
}


function init_double_pendulum() 
{
    // Create arm

    // Create static dummy body that we can constrain other bodies to
    dummyBody2 = new p2.Body({
        mass: 0,
    });
    world.addBody(dummyBody2);
    
    var armShape =  new p2.Box({ width: L1, height: 0.1*L });
    armShape.collisionGroup = DOUBLE;            
    armBody = new p2.Body({
        mass:1,
	position: [L1/2,0],
    });
    armBody.addShape(armShape,d1_arm_pos,initial_angle_deg);
    
    armBody.velocity = [0,0];
    
    armBody.angularVelocity = initAngVel;
    

    armBody.name = "armBody";
    world.addBody(armBody);
    armBody.color =  "0xffff00";

    bodies[armBody.name] = armBody;

    // Constrain it to the world
    var c = new p2.RevoluteConstraint(armBody, dummyBody2, {
        worldPivot: origin,
        collideConnected: false
    });

    world.addConstraint(c);

    // SecondArm
    var secondArmShape = new p2.Box({ width: L2, height: 0.1*L });
    armShape.collisionGroup = DOUBLE;            
    secondArmBody = new p2.Body({
        mass: 1,
	position: d2_arm_pos,
	angle: 0,
    });

    secondArmBody.velocity = [0,0];
    secondArmBody.angularVelocity = -initAngVel;    


    secondArmBody.addShape(secondArmShape);
    secondArmBody.name = "secondArmBody";
    secondArmBody.color = "0xf00f00";
    world.addBody(secondArmBody);

    bodies[secondArmBody.name] = secondArmBody;    

    // Connect secondArm to arm

    var c3 = new p2.RevoluteConstraint( armBody,secondArmBody, {
        localPivotA:
	    [L1/2 ,
	     0],
	localPivotB:
	[-L2/2,0],
        collideConnected: false
    });
    world.addConstraint(c3);
    
    armBody.angle = initial_angle;
    secondArmBody.angle = initial_angle;    
}

function init_single_pendulum()
{
    dummyBody1 = new p2.Body({
        mass: 0,
    });
    world.addBody(dummyBody1);
    
    // Create arm
    var sarmShape =  new p2.Box({ width: SL, height: 0.1*L });
    sarmShape.collisionGroup = SINGLE;        
    sarmBody = new p2.Body({
        mass:1,
	position: single_arm_pos,
    });
    sarmBody.addShape(sarmShape);
    sarmBody.color =  "0x0000ff";
    sarmBody.name = "sarmBody";
    
    sarmBody.angle = initial_angle;
    
    world.addBody(sarmBody);

    bodies[sarmBody.name] = sarmBody; 
    
    // Constrain it to the world
    var c = new p2.RevoluteConstraint(sarmBody, dummyBody1, {
        worldPivot: origin,
        collideConnected: false
    });
    world.addConstraint(c);

    armBody.angle = initial_angle;
    armBody.velocity = [0,0];
    armBody.angularVelocity = 0;
    
    secondArmBody.angle = initial_angle;
    secondArmBody.velocity = [0,0];
    secondArmBody.angularVelocity = 0;
    
    secondArmBody.color = random_color();
}

function reset_double_pendulum()
{
    world.removeBody(armBody);
    world.removeBody(secondArmBody);    
    world.removeBody(dummyBody2);    
    init_double_pendulum();

    var random_degree = Math.random() * 2.0;
    var random_rads = (random_degree / 360) * 2.0 * Math.PI;
    armBody.angle = initial_angle+random_rads;
    armBody.velocity = [0,0];
    armBody.angularVelocity = 0;
    
    secondArmBody.angle = initial_angle+random_rads;
    secondArmBody.velocity = [0,0];
    secondArmBody.angularVelocity = 0;
    
    secondArmBody.color = random_color();
}

function reset_single_pendulum()
{
    world.removeBody(sarmBody);
    world.removeBody(dummyBody1);    
    init_single_pendulum();
}

window.onkeydown = function(event){
    switch(event.keyCode){
    case 38: // up
    case 32: // space
        if(!buttons.space){
	    reset_single_pendulum();
	    reset_double_pendulum();
	    buttons.space = true;
        }
        break;
    case 39: // right
        buttons.right = true;
        break;
    case 37: // left
        buttons.left = true;
        break;
    }
}

window.onkeyup = function(event){
    switch(event.keyCode){
    case 38: // up
    case 32: // space
        buttons.space = false;
        break;
    case 39: // right
        buttons.right = false;
        break;
    case 37: // left
        buttons.left = false;
        break;
    }
}
    </script>

  </body>
    </html>
